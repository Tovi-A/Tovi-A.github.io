<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Fast R-CNN]]></title>
    <url>%2F2019%2F05%2F12%2FFast-R-CNN%2F</url>
    <content type="text"><![CDATA[论文下载：Fast R-CNN 摘要本文提出了一种基于快速区域的卷积网络方法（Fast R-CNN）用于目标检测。Fast R-CNN建立在先前的工作基础上，以使用深度卷积网络有效地对对象提取进行分类。与之前的工作相比，Fast R-CNN采用了多项创新来提高训练和测试速度，同时提高了检测精度。Fast R-CNN训练非常深的VGG16网络比R-CNN快9倍，在测试时间快213倍，并在PASCAL VOC 2012上实现更高的mAP。与SPPnet相比，Fast R-CNN训练VGG16 3倍速更快，测试速度快10倍，并且更准确。快速R-CNN在Python和C ++中实现（使用Caffe），可通过https：//github.com/rbgirshick/fast-rcnn的开源MIT许可证获得。 1. 介绍最近，深度ConvNets [14,16]显着改善了图像分类[14]和物体检测[9,19]的准确性。与图像分类相比，对象检测是一项更具挑战性的任务，需要更复杂的方法来解决。由于这种复杂性，当前的方法（例如，[9,11,19,25]）训练缓慢且不优雅的多级管道中的模型。复杂性的产生是因为检测需要对象的准确定位，从而产生两个主要挑战。首先，必须处理许多候选对象位置（通常称为“提取”）。其次，这些候选者仅提供粗略的本地化，必须对其进行细化以实现精确定位。解决这些问题往往会影响速度，准确性或简单性。在本文中，我们简化了最先进的基于ConvNet的物体探测器的训练过程[9,11]。我们提出了一种单阶段训练算法，该算法共同学习对对象提取进行分类并改进其空间位置。由此产生的方法可以训练一个非常深的检测网络（VGG16 [20]）比R-CNN [9]快9倍，比SPPnet [11]快3倍。在运行时，检测网络以0.3s处理图像（不包括对象提取时间）当实现PASCAL VOC 2012 [7]的最高精度，mAP为66％（R-CNN为62％）. 1.1 R-CNN and SPPnet基于区域的卷积网络方法（R-CNN）[9]通过使用深度ConvNet对对象提取进行分类，实现了出色的对象检测精度。然而，R-CNN有明显的缺点：1. 训练是一个多阶段的管道。 R-CNN首先使用对数损失函数对对象提取进行ConvNet微调。然后，调整SVM到ConvNet功能。这些SVM充当对象检测器，取代了通过微调学习的softmax分类器。在第三个训练阶段，学习边界框回归量。2. 训练在空间和时间上都很昂贵，代价很大。对于SVM和边界框回归训练，从每个图像中的每个对象提取中提取特征并将其写入磁盘。对于非常深的网络，例如VGG16，这个过程需要一天2.5个GPU才能获得VOC07 trainval set的5k张图像。这些功能需要数百GB的存储空间。3. 对象检测很慢。在测试时，从每个测试图像中的每个对象提议中提取特征。使用VGG16进行检测需要47秒/图像（在GPU上）。R-CNN很慢，因为它为每个对象提取执行ConvNet前向传递，而不共享计算。提出空间金字塔池化网络（SPPnets）[11]通过共享计算来加速R-CNN。 SPPnet方法计算整个输入图像的卷积特征映射，然后使用从共享特征映射中提取的特征向量对每个对象提取进行分类。通过将提取内部的特征地图的部分最大化为固定大小的输出（例如，6×6）来提取特征以用于提取。汇总多个输出大小，然后在空间金字塔池中连接[15]。 SPPnet在测试时将R-CNN加速10到100倍。由于更快的提案特征提取，训练时间也减少了3倍。SPPnet也有明显的缺点。与R-CNN一样，训练是一个多阶段管道，涉及提取特征，用对数损失函数微调网络，训练SVM，最后拟合边界框回归。特征也写入磁盘。但与R-CNN不同，[11]中提出的微调算法无法更新空间金字塔层之前的卷积层。不出所料，这种限制（固定卷积层）限制了非常深的网络的准确性。 1.2 Contributions我们提出了一种新的训练算法，它可以修复R-CNN和SPPnet的缺点，同时提高它们的速度和准确性。我们称这种方法为Fast R-CNN，因为它训练和测试的速度相对较快。快速R-CNN方法有几个优点： a. 比R-CNN,SPPnet更高的检测质量(mAP)b. 训练是单阶段的，使用多任务损失c. 训练可以更新所有的网络层d. 没有磁盘存储Fast R-CNN是用Python和C++编写的（Caffe [13]），可以通过https://github.com/rbgirshick/fast-rcnn的开源MIT许可证获得。 2. Fast R-CNN architecture and training 图1说明了Fast R-CNN架构。Fast R-CNN网络将整个图像和一组对象提取作为输入。网络首先使用几个卷积（conv）和最大池化层处理整个图像，以产生转换特征图。然后，对于每个对象提取，感兴趣区域（RoI）汇集层从特征映射中提取固定长度的特征向量。每个特征向量被馈送到一系列完全连接的（fc）层，最终分支成两个兄弟输出层：一个产生对K类对象类的softmax概率估计加上一个全能“背景”类和另一个输出层每个K对象类的四个实数值。每组4个值对K类之一的精细边界框位置进行编码。 2.1 The RoI pooling layerRoI池化层使用最大池来将任何有效感兴趣区域内的特征转换为具有固定空间范围H×W（例如，7×7）的小特征映射，其中H和W是层超参数。独立于任何特定的RoI。在本文中，RoI是一个转换特征映射的矩形窗口。每个RoI由四元组(r，c，h，w)定义，指定其左上角(r, c)及其高度和宽度$(h, w)$。RoI max pooling通过将$(hw)$ RoI窗口划分为大约$(h/H w/W)$的子窗口的$(H*W)$网格，然后将每个子窗口中的值最大汇集到相应的输出网格单元中来工作。池化独立应用于每个要素图通道，如标准最大池中所示。 RoI层只是SPPnets [11]中使用的空间金字塔池层的特例，其中只有一个金字塔层。我们使用[11]中给出的池子窗口计算。 2.2 Initializing from pre-trained networks我们试验了三个预先训练过的ImageNet [4]网络，每个网络有五个最大池化层和五到十三个卷积层（参见4.1节网络细节）。当预训练的网络初始化Fast R-CNN网络时，它经历三次转换。首先，最后一个最大池化层由RoI池化层替换，该池化层通过将H和W设置为与网络的第一个完全连接层相兼容来配置（例如，对于VGG16，H = W = 7）。其次，网络的最后一个完全连接层和softmax（用于1000路ImageNet分类的训练）被前面描述的两个兄弟层替换（完全连接层和softmax over K + 1类别和类别特定的边界框回归量）。第三，修改网络以获取两个数据输入：图像列表和那些图像中的RoI列表。 2.3 Fine-tuning for detection使用反向传播训练所有网络权重是Fast R-CNN的重要功能。首先，让我们阐明为什么SPPnet无法更新空间金字塔池层下的权重。根本原因是当每个训练样本（即RoI）来自不同的图像时，通过SPP层的反向传播非常低效，这正是R-CNN和SPPnet网络的训练方式。效率低下的原因在于每个RoI可能具有非常大的感受野，通常跨越整个输入图像。由于前向传播必须处理整个感受野，因此训练输入很大（通常是整个图像）。我们提出了一种更有效的训练方法，利用训练期间的特征共享。在Fast R-CNN训练中，随机梯度下降（SGD）小批量分层采样，首先采样N个图像，然后通过从每个图像采样R / N RoI。重要的是，来自相同图像的RoI在前向和后向传递中共享计算和存储器。使N小减少小批量计算。例如，当使用N = 2且R = 128时，所提出的训练方案比从128个不同图像采样一个RoI（即，R-CNN和SPPnet策略）快大约64倍。对该策略的一个担忧是它可能导致缓慢的训练收敛，因为来自相同图像的RoI是相关的。这个问题似乎不是一个实际问题，我们使用比R-CNN更少的SGD迭代，使用N = 2和R = 128获得了良好的结果。除了分层采样之外，Fast R-CNN还使用简化的训练过程和一个微调阶段，共同优化softmax分类器和边界框重建器，而不是在三个不同的阶段训练softmax分类器，SVM和回归器[9,11]。该过程的组件（损失，小批量采样策略，通过RoI池化层的反向传播和SGD超参数）如下所述。a. Multi-task loss. Fast R-CNN网络具有两个兄弟输出层。第一个输出离散概率分布（每个RoI），p =（p_0，...，p_K），超过K + 1个类别。通常，p由完全连接层的K + 1输出上的softmax计算。第二个兄弟层为每个K个对象类输出边界框回归偏移$t^k = (t^k x，t^k _y，t^k _w，t^k _h)$，由k索引。我们使用[9]中给出的$t^k$的参数化，其中t^k指定相对于对象提取的尺度不变的平移和对数空间高度/宽度转换。每个训练RoI都标有地面实况类u和地面真实边界框回归目标v。我们在每个标记的RoI上使用多任务损失L来联合训练分类和边界框回归： $L(p,u,t^u,v)= L{cls}(p,u)+λ[u≥1]L{loc}(t^u,v)$，（1）其中$L{cls}(p,u)= -log pu$是对数损失。第二个任务丢失$L{loc}$是在类u的真实边界框回归目标元组上定义的，$v=(vx，v_y，v_w，v_h)$和预测的元组$t^u =(t^u _x，t^u _y，t^u _w ，t^u _h)$，再次对类u。当u≥1时，[u≥1]评估为1，否则为0。按照惯例，全能背景类被标记为u = 0.对于背景RoI，没有地面真相的概念边界框，因此$L{loc}$被忽略。对于边界框回归，我们使用损失 是一种强大的L1损耗，对R-CNN和SPPnet中使用的L2损耗的异常值不太敏感。当回归目标无限制时，L2损失训练可能需要仔细调整学习速率以防止梯度爆炸。Eq.3消除了这种敏感性。Eq.1中的超参数λ控制两个任务损失之间的平衡。我们将地面实况回归目标$vi$标准化为零均值和单位方差。所有实验都使用$λ = 1$。我们注意到[6]使用相关损失来训练与类无关的对象提取网络。与我们的方法不同，[6]提出了一种将本地化和分类分开的双网络系统。 OverFeat [19]，R-CNN [9]和SPPnet [11]也训练分类器和边界框定位器，但是这些方法使用阶段式训练，我们表明它对于Fast R-CNN来说是次优的（第5.1节）。b. Mini-batch sampling.在微调期间，每个SGD小批量由N = 2个图像构成，随机均匀选择（通常的做法是，我们实际上迭代数据集的排列）。我们使用尺寸为R = 128的小批量，从每个图像中采样64个RoI。与[9]中一样，我们从具有交叉联合（IoU）重叠的对象提取中获取25％的RoI与至少0.5的地面实例边界框重叠。这些RoI包括用前景对象类标记的示例，即u≥1。剩余的RoI是从对象提议中采样的，在[11,0]之后的区间[0.1,0.5]中具有最大IoU与地面实况。这些是背景示例，并标有u = 0. 0.1的下限阈值似乎充当了硬实例挖掘的启发式算法[8]。在训练期间，图像以0.5的概率水平翻转。没有使用其他数据扩充。c. Back-propagation through RoI pooling layers.反向传播通过RoI池化层路由衍生物。为清楚起见，我们假设每个小批量只有一个图像（N = 1），尽管N&gt;1的扩展是直截了当的，因为前向传递独立地处理所有图像。令$x_i∈R$是进入RoI池化层的第i个激活输入，并且让$y{rj}$成为来自第r个RoI的层的第j个输出。 RoI池化层计算$y{rj} = x{i （r，j）}$，其中$i （r，j）=argmax{i^`∈R（r，j）}x{i^`}$。 $R（r，j）$是子窗口中输入的索引集，输出单元$y{rj}$ 在该子窗口中汇集。可以将单个$x_i$分配给几个不同的输出$y{rj}$。RoI池化层的向后函数通过遵循argmax开关计算损失函数相对于每个输入变量xi的偏导数： 换句话说，对于每个小批量RoI r和每个池化输出单元$y_{rj}$，如果i是通过最大合并为yrj选择的argmax，则累积偏导数∂L/∂yrj。在反向传播中，偏导数∂L/∂yrj已经由RoI汇集层顶部的层的向后函数计算。c. SGD hyper-parameters.用于softmax分类和边界框回归的完全连接的层分别从零均值高斯分布初始化，标准偏差分别为0.01和0.001。偏差初始化为0.所有层使用权重的每层学习率为1，偏差为2，全局学习率为0.001。在训练VOC07或VOC12 trainval时，我们运行SGD进行30k小批量迭代，然后将学习率降低到0.0001，并进行另外10k次迭代训练。当我们在更大的数据集上训练时，我们运行SGD以进行更多迭代，如稍后所述。使用0.9的动量和0.0005的参数衰减（基于重量和偏差）。 2.4 Scale invariance我们探索了实现尺度不变对象检测的两种方法：（1）通过“强力”学习和（2）使用图像金字塔。这些策略遵循[11]中的两种方法。在蛮力方法中，在训练和测试期间以预定义的像素大小处理每个图像。网络必须直接从训练数据中学习尺度不变的物体检测。相反，多尺度方法通过图像金字塔为网络提供近似的尺度不变性。在测试时，图像金字塔用于近似地对每个对象提取进行缩放标准化。在多尺度训练期间，我们在每次采样图像后随机采样金字塔尺度，[11]，作为数据增强的一种形式。由于GPU内存限制，我们仅尝试针对较小网络的多规模培训。 3. Fast R-CNN detection一旦对Fast R-CNN网络进行微调，检测就会比运行正向传递更多（假设对象提取是预先计算的）。网络将图像（或图像金字塔，编码为图像列表）和R对象提议列表作为输入。在测试时间，R通常在2000左右，但我们会考虑它更大的情况（≈45k）。当使用图像金字塔时，每个RoI被分配给比例，使得缩放的RoI最接近区域中的$224^2$像素[11]。对于每个测试RoI r，前向传递输出类后验概率分布p和一组相对于r的预测边界框偏移（每个K类获得其自己的精细边界框预测）。我们使用估计概率$P_r（class = k | r）=Δ p_k$为每个对象类k分配r的检测置信度。然后，我们使用R-CNN [9]的算法和设置，为每个类独立地执行非最大抑制。 3.1 Truncated SVD for faster detection对于全图像分类，与conv层相比，计算完全连接层所花费的时间较少。相反，为了检测，要处理的RoI的数量很大，并且将近一半的正向传播时间用于计算完全连接的层（参见图2）。通过截断的SVD压缩它们可以很容易地加速大的完全连接层[5,23]。在该技术中，由u×v权重矩阵W参数化的层近似地分解为 使用SVD。在该因式分解中，U是包含W的前t个左奇异向量的au×t矩阵，Σt是包含W的前t个奇异值的×t对角矩阵，并且V是包含第一个t右的v×t矩阵 - W的奇异向量。截断的SVD将参数计数从uv减少到t（u + v），如果t远小于min（u，v），则可能是显着的。为了压缩网络，对应于W的单个完全连接层被两个完全连接的层代替，它们之间没有非线性。这些层中的第一层使用权重矩阵ΣtVT（并且没有偏差），第二层使用U（原始双向与W相关联）。当RoI数量很大时，这种简单的压缩方法可以提供良好的加速。 6. Conclusion本文提出了Fast R-CNN，一种干净，快速的R-CNN和SPPnet更新。 除了报告最先进的检测结果外，我们还提供了详细的实验，希望能够提供新的见解。特别值得注意的是，稀疏对象提取似乎可以提高检测器质量。 这个问题在过去进行探测时成本太高（及时），但对于Fast R-CNN变得切实可行。当然，可能存在尚未发现的技术，这些技术允许密集的框执行以及稀疏的提议。如果开发出这样的方法，可以帮助进一步加速物体检测。]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs231n-2017spring-笔记]]></title>
    <url>%2F2019%2F05%2F11%2Fcs231n-2017spring-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Detection and Segmentation在这一小节，我们将讨论分割、定位、检测。 语义分割(Semantic Segmentation) FCN参考链接 在下面这张图中，我们想用标记策略去标记每一个像素点。 在上图右边，语义分割不会去区分一个实例，仅仅关心像素点。 使用一个滑动窗口，采用一个小的窗口大小在整张图片上滑动。对于每一个窗口，我们想标记每一个中心像素点。a. 它能够工作，但是不是一个好的idea，因为它的计算非常复杂。 b. 非常不高效的。不会重复使用重叠部分的共享特性。所以在训练中，并没有人使用这种方法。 将网络设计成一个卷基层，同时对所有像素点进行预测。 a. 输入是整张image，输出是图片中每一个像素点的标记。b. 我们需要大量的标记数据，并且这些标记数据是非常昂贵的。c. 这种方案需要更深的卷积层。d. 损失函数是每一个像素点的交叉熵损失。e. 数据增强在这里表现很好。f. 在原始图像下，这种卷积的生成非常昂贵。g. 实际上，我们现在还没有看到这样的情况。 基于第二种方案，不同点是在网络中采用了下采样与上采样。 图像的上采样与下采样由于使用整张图片是非常昂贵的。因此首先多个层使用下采样，然后最后使用上采样。 下采样类似于池化操作。上采样类似于”Nearest Neighbor” or “Bed of Nails” or “Max unpooling”。 Max unpooling是上采样中最好的方案。 卷积转置]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目标检测]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[参考链接]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BAT经典面试题]]></title>
    <url>%2F2019%2F05%2F04%2FBAT%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[实现一个Memcpy函数memcpy函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中。 12345678910111213141516171819202122232425262728void *memcpy(void *dst, const void *src, size_t len)&#123; if(NULL == dst || NULL == src)&#123; return NULL; &#125; void *ret = dst; if(dst &lt;= src || (char *)dst &gt;= (char *)src + len)&#123; //没有内存重叠，从低地址开始复制 while(len--)&#123; *(char *)dst = *(char *)src; dst = (char *)dst + 1; src = (char *)src + 1; &#125; &#125; else&#123; //有内存重叠，从高地址开始复制 src = (char *)src + len - 1; dst = (char *)dst + len - 1; while(len--)&#123; *(char *)dst = *(char *)src; dst = (char *)dst - 1; src = (char *)src - 1; &#125; &#125; return ret;&#125; STL中vector的实现原理 (衍生：Map, Set等实现原理)vector的数据安排以及操作方式，与array非常相似。两者的唯一区别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变；要换个大（或小）一点的房子，可以，一切琐细都得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来的空间释还给系统。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始要求一个大块头的array了，我们可以安心使用array，吃多少用多少。 vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。一旦vector的旧有空间满载，如果客户端每新增一个元素，vector的内部只是扩充一个元素的空间，实为不智。因为所谓扩充空间（不论多大），一如稍早所说，是” 配置新空间/数据移动/释还旧空间 “的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。稍后我们便可看到SGI vector的空间配置策略了。 另外，由于 vector维护的是一个连续线性空间，所以vector支持随机存取 。 注意：vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此， 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 。这是程序员易犯的一个错误，务需小心。 给定N张扑克牌和一个随机函数，设计一个洗牌算法1234567891011121314void shuffle(int cards[],int n)&#123; if(cards==NULL) return ; srand(time(0)); for(int i=0;i&lt;n-1;++i) &#123; //保证每次第i位的值不会涉及到第i位以前 int index=i+rand()%(n-i); swap(cards[index], cards[i]); //交换位置，抽到了第i张牌，后面不会再用了，所以交换 &#125;&#125; 假定Ｎ=54，首先，我们有一个随机函数发生器，能够产生1-54之间的随机数，如何保证抽第一张牌是54中可能，抽第二张牌是53中可能，…… 可以这样做，假设扑克牌是一个54维的数组card， 我们要做的就是从这个数组中随机取一个元素，然后在剩下的元素里再随机取一个元素… 这里涉及到一个问题，就是每次取完元素后，我们就不会让这个元素参与下一次的选取。 我们要实现的目的是以等概率的方式将这54个数随机打乱排列，因此，可以这样处理： 第一次抽牌在初始54张牌中，将 随机产生的牌x，与第一个元素互换， 第二次抽牌在剩下的53张牌中，将 随机产生的牌y，与第二个元素互换， …… 25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？参考链接]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode%2F</url>
    <content type="text"><![CDATA[dfs-784. Letter Case Permutation题目链接123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; ans; vector&lt;string&gt; letterCasePermutation(string S) &#123; dfs(S, 0); return ans; &#125; void dfs(string s, int u) &#123; if (u == s.size()) &#123; ans.push_back(s); return ; &#125; dfs(s, u + 1); if (s[u] &gt;= 'A') &#123; s[u] ^= 32; dfs(s, u + 1); &#125; &#125;&#125;; 12345678910111213141516class Solution: ans = [] def dfs(self, s, u): s = list(s) if (u == len(s)): s = ''.join(s) self.ans.append(s) return self.dfs(s, u + 1) if (s[u] &gt;= 'A'): s[u] = chr(ord(s[u]) ^ 32) # ASCII码与字符相互转换 self.dfs(s, u + 1) def letterCasePermutation(self, S: str) -&gt; List[str]: self.ans = [] self.dfs(S, 0) return self.ans dfs-77. Combinations题目链接 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; path; dfs(path, 1, n, k); return ans; &#125; void dfs(vector&lt;int&gt; &amp;path, int start, int n, int k) &#123; if (k == 0) &#123; ans.push_back(path); return ; &#125; for (int i = start; i &lt;= n; i ++) &#123; path.push_back(i); dfs(path, i + 1, n, k - 1); path.pop_back(); &#125; &#125;&#125;; 1234567891011121314151617class Solution: ans = [] def combine(self, n: int, k: int) -&gt; List[List[int]]: path = [] self.ans = [] self.dfs(path, 1, n, k) return self.ans def dfs(self, path, start, n, k): if k == 0: path = list(path) self.ans.append(path) return for i in range(start, n + 1): path.append(i) self.dfs(path, i + 1, n, k - 1) path.pop() dfs-257. Binary Tree Paths题目链接 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; ans; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; string path; dfs(root, path); return ans; &#125; void dfs(TreeNode* root, string path) &#123; if (!root) return ; if (path.size()) path += "-&gt;"; path += to_string(root-&gt;val); if (!root-&gt;left &amp;&amp; !root-&gt;right) ans.push_back(path); else &#123; dfs(root-&gt;left, path); dfs(root-&gt;right, path); &#125; &#125;&#125;; 12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: ans = [] def binaryTreePaths(self, root: TreeNode) -&gt; List[str]: self.ans = [] path = "" self.dfs(root, path) return self.ans def dfs(self, root, path): if (not root): return if (len(path)): path += "-&gt;" path = path + str(root.val) if (not root.left and not root.right): self.ans.append(path) else: self.dfs(root.left, path) self.dfs(root.right, path) dfs-93. Restore IP Addresses题目链接 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; ans; vector&lt;string&gt; restoreIpAddresses(string s) &#123; string path; dfs(s, 0, 0, path); return ans; &#125; void dfs(string &amp;s, int u, int k, string path) &#123; if (u == s.size()) &#123; if (k == 4) &#123; ans.push_back(path.substr(1)); &#125; return ; &#125; if (k &gt; 4) return ; if (s[u] == '0') dfs(s, u + 1, k + 1, path + ".0"); else &#123; for (int i = u, t = 0; i &lt; s.size(); i ++ ) &#123; t = t * 10 + s[i] - '0'; if ( t &lt; 256) dfs(s, i + 1, k + 1, path + '.' + to_string(t)); else break; &#125; &#125; &#125;&#125;; dfs-95. Unique Binary Search Trees II题目链接 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (!n) return vector&lt;TreeNode*&gt;(); return dfs(1, n); &#125; vector&lt;TreeNode*&gt; dfs(int l, int r) &#123; vector&lt;TreeNode*&gt; res; if (l &gt; r) &#123; res.push_back(NULL); return res; &#125; for (int i = l; i &lt;= r; i ++ ) &#123; auto left = dfs(l, i-1), right = dfs(i + 1, r); for (auto &amp;lt : left) &#123; for (auto &amp; rt : right) &#123; auto root = new TreeNode(i); root-&gt;left = lt, root-&gt;right = rt; res.push_back(root); &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis学习]]></title>
    <url>%2F2019%2F04%2F18%2Fredis%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[RDB持久化将服务器中的非空数据库以及它们的键值对统称为数据库状态。redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。由此，redis提供了RDB持久化功能，它可以将redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原数据库状态，如图所示： RDB文件的创建与载入生成RDB文件命令：SAVE、BGSAVE SAVE命令会阻塞redis服务器进程，直到RDB文件创建完毕为止，在阻塞期间，服务器不能处理任何命令请求。 GBSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。只要redis服务器在启动时候检测到RDB文件的存在，就会自动载入RDB文件。由于AOF文件的更新频率通常比RDB文件的更新频率高，所以： 如果服务器有开启AOF持久化功能，那么会优先使用AOF文件来还原数据库状态。 只有AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。服务器判断该用哪个文件来还原数据库状态的流程以及rdbLoad与rdbSave函数之间的关系如图：服务器只有在执行完SAVE命令之后，客户端发送的命令才会被处理。BGSAVE执行期间，redis服务器可以处理客户端的请求。 BGSAVE执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE与BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。 BGSAVE执行期间，客户端发送的BGSAVE会被拒绝，同时执行两个BGSAVE也会产生竞争条件。 BGREWRITEAOF和BGSAVE两个命令不能同时执行。服务器在载入RDB文件时候，一直处于阻塞状态，知道载入完成。自动间隔性保存SAVE由父进程执行保存工作，而BGSAVE由子进程执行保存工作。因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以redis允许用户通过设置服务器配置save选项，让服务器每隔一段时间自动执行一次BGSAVE。 redis服务器是如何根据save选项设置的保存条件，自动执行BGSAVE命令？dirty计数器和lastsave属性： dirty计数器的值为123，则表示服务器在上次保存之后，对数据库状态共进行了123次修改。 lastsave属性则记录了服务器上次执行保存操作的时间。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习＆深度学习面试]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%86%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[本文为将来的面试鉴定基础，同时也算对于各知识点的一个归纳总结。一天一更新~~SGD,Momentum,Adagard,Adam原理参考链接 梯度下降法的三种形式（BGD、SGD、MBGD）参考链接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#coding=utf-8import numpy as npimport random#下面实现的是批量梯度下降法def batchGradientDescent(x, y, theta, alpha, m, maxIterations): xTrains = x.transpose() #得到它的转置 for i in range(0, maxIterations): hypothesis = np.dot(x, theta) #print("batch", x.shape, theta.shape) loss = hypothesis - y # print loss gradient = np.dot(xTrains, loss) / m #对所有的样本进行求和，然后除以样本数 theta = theta - alpha * gradient return theta#下面实现的是随机梯度下降法def StochasticGradientDescent(x, y, theta, alpha, m, maxIterations): data = [] for i in range(10): data.append(i) xTrains = x.transpose() #变成3*10，没一列代表一个训练样本 # 这里随机挑选一个进行更新点进行即可（不用像上面一样全部考虑） for i in range(0,maxIterations): hypothesis = np.dot(x, theta) loss = hypothesis - y #注意这里有10个样本的，我下面随机抽取一个进行更新即可 index = random.sample(data,1) #任意选取一个样本点，得到它的下标,便于下面找到xTrains的对应列 index1 = index[0] #因为回来的时候是list，我要取出变成int，更好解释 gradient = loss[index1]*x[index1] #只取这一个点进行更新计算 theta = theta - alpha * gradient.T return thetadef predict(x, theta): m, n = np.shape(x) xTest = np.ones((m, n+1)) #在这个例子中，是第三列放1 xTest[:, :-1] = x #前俩列与x相同 res = np.dot(xTest, theta) #预测这个结果 return restrainData = np.array([[1.1,1.5,1],[1.3,1.9,1],[1.5,2.3,1],[1.7,2.7,1],[1.9,3.1,1],[2.1,3.5,1],[2.3,3.9,1],[2.5,4.3,1],[2.7,4.7,1],[2.9,5.1,1]])trainLabel = np.array([2.5,3.2,3.9,4.6,5.3,6,6.7,7.4,8.1,8.8])print("train shape: ", trainLabel.shape)m, n = np.shape(trainData)print(m, n)theta = np.ones(n)print(np.shape(theta))print(theta)alpha = 0.1maxIteration = 5000#下面返回的theta就是学到的thetatheta = batchGradientDescent(trainData, trainLabel, theta, alpha, m, maxIteration)print ("theta = ",theta)x = np.array([[3.1, 5.5], [3.3, 5.9], [3.5, 6.3], [3.7, 6.7], [3.9, 7.1]])print (predict(x, theta))theta = StochasticGradientDescent(trainData, trainLabel, theta, alpha, m, maxIteration)print ("theta = ",theta)x = np.array([[3.1, 5.5], [3.3, 5.9], [3.5, 6.3], [3.7, 6.7], [3.9, 7.1]])print (predict(x, theta))#yes,is the codey = np.array([2])# y = np.array([[1], [1], [1]])print(y.shape)nn = np.ones(3) # nn = [1, 1, 1]mm = np.array([[1], [1], [1]])print(mm.shape)res = np.dot(mm.T, nn)print(res)print(nn)print(nn.shape) L1不可导的时候该怎么办参考回答:当损失函数不可导,梯度下降不再有效,可以使用坐标轴下降法,梯度下降是沿着当前点的负梯度方向进行参数更新,而坐标轴下降法是沿着坐标轴的方向,假设有m个特征个数,坐标轴下降法进参数更新的时候,先固定m-1个值,然后再求另外一个的局部最优解,从而避免损失函数不可导问题。使用Proximal Algorithm对L1进行求解,此方法是去优化损失函数上界结果。参考链接 l1 相比于 l2 为什么容易获得稀疏解？参考链接]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面试]]></title>
    <url>%2F2019%2F04%2F13%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[C/C++中static关键字作用总结参考链接：参考链接 写出完整版的strcpy函数三个点： 将源字符串加const,表明其为输入参数。 对源地址和目标地址加非空断言。 将目标地址返回。123456char *strcpy(char *strDest, const char *strSrc) &#123; assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); char *address = strDest; while ( (*strDest++ == *strSrc++) != '\0'); return address;&#125; C++中基类的析构函数为什么要用virtual虚析构函数在基类的析构函数为非虚析构函数的时候，并不一定会造成内存泄漏；当派生类对象的析构函数中有内存需要收回，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将该对象销毁，这时，就会因为基类的析构函数为非虚析构函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。 C++中的纯虚函数在什么情况下使用纯虚函数(pure vitrual function)? 1，当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化； 2，这个方法必须在派生类(derived class)中被实现；]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basic Structures for Deep Learning Models]]></title>
    <url>%2F2019%2F04%2F11%2FBasic-Structures-for-Deep-Learning-Models%2F</url>
    <content type="text"><![CDATA[RNN(循环神经网络)参考链接：RNN 不容易过拟合，比较好的处理sequence. h’与h、b’与b的维度必须都一样。 双向RNN,f3存在的目的就是将f1与f2的output合在一起。 锥体RNN，好处是可以将sequence缩短。 一个RNN的样子。其中y是从h’算出来的。（最简单的RNN) LSTM(长短时记忆网络)(https://blog.csdn.net/jiede1/article/details/58595418) $c^t$ 、$h^t$接其他的LSTM,LSTM的输入有两个vector,h是变化非常快的，而c变化较慢（记住以前的information） LSTM的架构，将$x^t$与$h^{t-1}$分别乘以不同的matrix. $c^{t-1}$的作用。 将$z^i$与$z$相乘，维度相同，再相加，得到$c^t$. 再次循环，反复使用。 GRUGRU不像LSTM有两个速度不一样的输入。出的箭头表示乘上了一个matrix，上面那个等式是$h{t-1}$,GRU的运算量比较小。 下一层只连接上一层的若干块。（每一个神经元只管皮肤的一小块部分） 不同的神经元可以有相同的参数（参数共享）]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces]]></title>
    <url>%2F2019%2F04%2F10%2Fcodeforces%2F</url>
    <content type="text"><![CDATA[A. Ilya and a Colorful Walk题目链接：A. Ilya and a Colorful Walk 题目大意：有n个房子，每个房子染着不同的颜色，保证至少有两个房子有着不同的颜色，让你找出这n个房子中的两个不同颜色房子的最大距离是多少。 解法：分别固定首尾扫描n个房子。123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int a[300000+100];int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i&lt;n; i++) scanf("%d", &amp;a[i]); int res = 0, l = 0, r = n-1; while (l &lt; r &amp;&amp; a[l] == a[r]) r--; res = r-l; l = 0, r = n-1; while (l &lt; r &amp;&amp; a[l] == a[r]) l++; if (r-l &gt; res) res = r-l; printf("%d\n", res); return 0;&#125; B. Alyona and a Narrow Fridge题目链接：B. Alyona and a Narrow Fridge 题目大意：告诉你有n个瓶子与这n个瓶子的高度，冰箱的高度h，冰箱宽2，则让你求将前k个瓶子都能放入冰箱的最大值k。（瓶子必须放在架子之上）解法：分别将前k个瓶子放入一个数组b，对b进行排序，从最高的开始，如果当前可以装，则取下下个，直到数组b中所有瓶子都能装下，则表示此k值可取。然后k增加1，循环~1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[1000+100];int b[1000+100];int main() &#123; int n, h, res = 0; scanf("%d%d", &amp;n, &amp;h); for (int i = 0; i&lt;n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i&lt;n; i++) &#123; int flag = 0, num = h; memset(b, 0, sizeof(b)); for (int j = 0; j&lt;=i; j++) b[j] = a[j]; sort(b, b+i+1); for (int j = i; j&gt;=0; j--) &#123; if (num &gt;= b[j]) &#123; num -= b[j]; j --; &#125; else &#123; flag = 1; break; &#125; &#125; if (flag == 0) res = i+1; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[调整数组顺序使奇数位于偶数前面题目链接：题目链接题解：题解1234567891011class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; int l = 0, r = array.size()-1; while (l &lt; r) &#123; while (array[l]%2 == 1) l ++; while (array[r]%2 == 0) r --; if (l &lt; r) swap(array[l], array[r]); &#125; &#125;&#125;; 链表中倒数第k个节点题目链接：题目链接题解：题解12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* findKthToTail(ListNode* pListHead, int k) &#123; int n = 0; for (auto p = pListHead; p; p = p-&gt;next) n ++ ; if (k &gt; n) return NULL; auto p = pListHead; for (int i = 0; i&lt;n-k; i++) p = p-&gt;next; return p; &#125;&#125;; 链表中环的入口结点题目链接：题目链接题解：题解12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *entryNodeOfLoop(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return NULL; ListNode *first = head, *second = head; while (first &amp;&amp; second) &#123; first = first-&gt;next; second = second-&gt;next; if (second) second = second-&gt;next; else return NULL; if (first == second) &#123; first = head; while (first != second) &#123; first = first-&gt;next; second = second-&gt;next; &#125; return first; &#125; &#125; return NULL; &#125;&#125;; 反转链表题目链接：题目链接题解：题解12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *prev = NULL; ListNode *cur = head; while (cur) &#123; ListNode *next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; &#125; return prev; &#125;&#125;; 合并两个排序的链表题目链接：题目链接1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* merge(ListNode* l1, ListNode* l2) &#123; ListNode* dumy = new ListNode(0); ListNode* res = dumy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; dumy-&gt;next = l1; //尾插法 l1 = l1-&gt;next; &#125; else &#123; dumy-&gt;next = l2; l2 = l2-&gt;next; &#125; dumy = dumy-&gt;next; &#125; if (l1) dumy-&gt;next = l1; if (l2) dumy-&gt;next = l2; return res-&gt;next; &#125; &#125;; 树的子结构题目链接：题目链接题解：题解1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (!pRoot1 || !pRoot2) return false; if (isSame(pRoot1, pRoot2)) return true; return hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2); &#125; bool isSame(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (!pRoot2) return true; if (!pRoot1 || pRoot1-&gt;val != pRoot2-&gt;val) return false; return isSame(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSame(pRoot1-&gt;right, pRoot2-&gt;right); &#125;&#125;; 二叉树的镜像题目链接：题目链接题解：题解123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void mirror(TreeNode* root) &#123; if (root == NULL) return ; swap(root-&gt;left, root-&gt;right); mirror(root-&gt;left); mirror(root-&gt;right); &#125;&#125;; 对称的二叉树题目链接：题目链接题解：题解1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return !root || dfs(root-&gt;left, root-&gt;right); &#125; bool dfs(TreeNode *p, TreeNode *q) &#123; if (!p || !q) return !p &amp;&amp; !q; return p-&gt;val == q-&gt;val &amp;&amp; dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); &#125;&#125;; 顺时针打印矩阵题目链接：题目链接题解：题解12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; vector &lt;int&gt; res; int n = matrix.size(); if (!n) return res; int m = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false)); int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //四个方向，上右下左 int x = 0, y = 0, d = 1; //d表示方向，开始第一个下标 for (int i = 0; i&lt;n * m; i++) &#123; res.push_back(matrix[x][y]); st[x][y] = true; int a = x + dx[d], b = y + dy[d]; if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b]) &#123; d = (d+1) % 4; a = x + dx[d], b = y + dy[d]; &#125; x = a, y = b; &#125; return res; &#125;&#125;; 包含min函数的栈题目链接：题目链接题解：题解123456789101112131415161718192021222324252627282930313233343536class MinStack &#123;public: /** initialize your data structure here. */ stack &lt;int&gt; s; stack &lt;int&gt; Min; MinStack() &#123; &#125; void push(int x) &#123; s.push(x); if (Min.empty() || Min.top() &gt; x) Min.push(x); &#125; void pop() &#123; if (s.top() == Min.top()) Min.pop(); s.pop(); &#125; int top() &#123; return s.top(); &#125; int getMin() &#123; return Min.top(); &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 栈的压入、弹出序列题目链接：题目链接1234567891011121314151617class Solution &#123;public: bool isPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; if (pushV.size() != popV.size()) return false; stack &lt;int&gt; s; int num = 0; for (int i = 0; i&lt;pushV.size(); i++) &#123; s.push(pushV[i]); while (!s.empty() &amp;&amp; popV[num] == s.top()) &#123; s.pop(); num ++ ; &#125; &#125; if (s.empty()) return true; return false; &#125;&#125;; 不分行从上往下打印二叉树题目链接：题目链接1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; printFromTopToBottom(TreeNode* root) &#123; vector &lt;int&gt; res(0); queue &lt;TreeNode*&gt; q; if (root == NULL) return res; q.push(root); while (!q.empty()) &#123; TreeNode* cur = q.front(); q.pop(); res.push_back(cur-&gt;val); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; return res; &#125;&#125;; 分行从上往下打印二叉树题目链接：题目链接12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;TreeNode* &gt; q; q.push(root); q.push(nullptr); //队列里面加一个标记nullptr表示这一层已经结束了 vector&lt;int&gt; level; while (q.size()) &#123; auto t = q.front(); q.pop(); if (!t) &#123; if (level.empty()) break; res.push_back(level); level.clear(); q.push(nullptr); continue; &#125; level.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; return res; &#125;&#125;; 之字形打印二叉树题目链接：题目链接123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;TreeNode* &gt; q; q.push(root); q.push(nullptr); int flag = false; vector&lt;int&gt; level; while (q.size()) &#123; auto t = q.front(); q.pop(); if (!t) &#123; if (level.empty()) break; if (flag) reverse(level.begin(), level.end()); flag = !flag; res.push_back(level); level.clear(); q.push(nullptr); continue; &#125; level.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; return res; &#125;&#125;; 二叉搜索树的后序遍历序列题目链接:题目链接1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; seq; bool verifySequenceOfBST(vector&lt;int&gt; sequence) &#123; seq = sequence; return dfs(0, seq.size()-1); &#125; bool dfs(int l, int r) &#123; if (l &gt;= r) return true; int root = seq[r]; int k = l; while (k &lt; r &amp;&amp; seq[k] &lt; root) k ++ ; for (int i = k; i &lt; r; i++) &#123; //判断右子树是否合法 if (seq[i] &lt; root) return false; &#125; return dfs(l, k - 1) &amp;&amp; dfs(k, r-1); &#125;&#125;; 二叉树中和为某一值的路径题目链接：题目链接1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; findPath(TreeNode* root, int sum) &#123; dfs(root, sum); return ans; &#125; void dfs(TreeNode *root, int sum) &#123; if (!root) return ; path.push_back(root-&gt;val); sum -= root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum) ans.push_back(path); dfs(root-&gt;left, sum); dfs(root-&gt;right, sum); path.pop_back(); //恢复原状 &#125;&#125;; 复杂链表的复刻题目链接：题目链接1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list with a random pointer. * struct ListNode &#123; * int val; * ListNode *next, *random; * ListNode(int x) : val(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *copyRandomList(ListNode *head) &#123; if (head == NULL) return NULL; for (auto p = head; p; ) &#123; ListNode *next = p-&gt;next; ListNode *tmp = new ListNode(p-&gt;val); tmp-&gt;next = p-&gt;next; p-&gt;next = tmp; p = next; &#125; for (auto p = head; p; p = p-&gt;next) &#123; if (p-&gt;random) &#123; p-&gt;next-&gt;random = p-&gt;random-&gt;next; p = p-&gt;next; &#125; &#125; ListNode *dumy = new ListNode(-1); ListNode *p = dumy; while (head) &#123; p-&gt;next = head-&gt;next; head = head-&gt;next-&gt;next; p = p-&gt;next; &#125; return dumy-&gt;next; &#125;&#125;; 二叉搜索树与双向链表题目链接：题目链接讲解视频：讲解视频123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* convert(TreeNode* root) &#123; if (!root) return NULL; auto sides = dfs(root); return sides.first; &#125; pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode *root) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right) return &#123;root, root&#125;; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; auto lsides = dfs(root-&gt;left), rsides = dfs(root-&gt;right); lsides.second-&gt;right = root, root-&gt;left = lsides.second; root-&gt;right = rsides.first, rsides.first-&gt;left = root; return &#123;lsides.first, rsides.second&#125;; &#125; if (root-&gt;left) &#123; auto lsides = dfs(root-&gt;left); lsides.second-&gt;right = root, root-&gt;left = lsides.second; return &#123;lsides.first, root&#125;; &#125; if (root-&gt;right) &#123; auto rsides = dfs(root-&gt;right); root-&gt;right = rsides.first, rsides.first-&gt;left = root; return &#123;root, rsides.second&#125;; &#125; &#125;&#125;; 序列化二叉树题目链接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string res; dfs_s(root, res); return res; &#125; void dfs_s(TreeNode *root, string &amp;res) &#123; if (!root) &#123; res += "null "; return ; &#125; res += to_string(root-&gt;val) + ' '; dfs_s(root-&gt;left, res); dfs_s(root-&gt;right, res); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; int u = 0; return dfs_d(data, u); &#125; TreeNode* dfs_d(string data, int &amp;u) &#123; if (u == data.size()) return NULL; int k = u; while (data[k] != ' ') k ++ ; if (data[u] == 'n') &#123; u = k + 1; return NULL; &#125; int val = 0; for (int i = u; i &lt; k; i++) val = val * 10 + data[i] - '0'; u = k + 1; auto root = new TreeNode(val); root-&gt;left = dfs_d(data, u); root-&gt;right = dfs_d(data, u); return root; &#125;&#125;; 数字排列题目链接123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) &#123; path.resize(nums.size()); sort(nums.begin(), nums.end()); dfs(nums, 0, 0, 0); return ans; &#125; void dfs(vector&lt;int&gt; &amp;nums, int u, int start, int state) &#123; if (u == nums.size()) &#123; ans.push_back(path); return ; &#125; if (!u || nums[u] != nums[u-1]) start = 0; for (int i = start; i&lt;nums.size(); i++) &#123; if (!(state &gt;&gt; i &amp; 1)) &#123; path[i] = nums[u]; dfs(nums, u + 1, i + 1, state + (1 &lt;&lt; i)); &#125; &#125; &#125;&#125;; 数组中出现次数超过一半的数字题目链接1234567891011121314class Solution &#123;public: int moreThanHalfNum_Solution(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0, val = -1; for (auto x : nums) &#123; if (!cnt) val = x, cnt = 1; else &#123; if (x == val) cnt ++ ; else cnt -- ; &#125; &#125; return val; &#125;&#125;; 最小的k个数题目链接12345678910111213141516class Solution &#123;public: vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; priority_queue&lt;int&gt; heap; for (auto x : input) &#123; heap.push(x); if (heap.size() &gt; k) heap.pop(); &#125; vector&lt;int&gt; res; while (heap.size()) res.push_back(heap.top()), heap.pop(); reverse(res.begin(), res.end()); return res; &#125;&#125;; 数据流中的中位数题目链接12345678910111213141516171819202122232425class Solution &#123;public: priority_queue&lt;int&gt; max_heap; //大根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap; //小根堆 void insert(int num)&#123; max_heap.push(num); if (min_heap.size() &amp;&amp; max_heap.top() &gt; min_heap.top()) &#123; auto maxv = max_heap.top(), minv = min_heap.top(); max_heap.pop(), min_heap.pop(); max_heap.push(minv), min_heap.push(maxv); &#125; if (max_heap.size() &gt; min_heap.size() + 1) &#123; min_heap.push(max_heap.top()); max_heap.pop(); &#125; &#125; double getMedian()&#123; if ((max_heap.size() + min_heap.size()) &amp; 1) return max_heap.top(); return (max_heap.top() + min_heap.top()) / 2.0; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F04%2F07%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[实现单链表的逆序迭代翻转即将所有节点的next指针指向前驱节点。由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。 空间复杂度分析：遍历时只有3个额外变量，所以额外的空间复杂度是 O(1)。时间复杂度分析：只遍历一次链表，时间复杂度是 O(n）。12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *prev = nullptr; ListNode *cur = head; while (cur) &#123; ListNode *next = cur-&gt;next; cur-&gt;next = prev; prev = cur, cur = next; &#125; return prev; &#125;&#125;; 递归首先我们先考虑 reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点。所以我们可以先递归处理 reverseList(head-&gt;next)，这样我们可以将以head-&gt;next为头节点的链表翻转，并得到原链表的尾节点tail，此时head-&gt;next是新链表的尾节点，我们令它的next指针指向head，并将head-&gt;next指向空即可将整个链表翻转，且新链表的头节点是tail。 空间复杂度分析：总共递归 n 层，系统栈的空间复杂度是 O(n)，所以总共需要额外 O(n)的空间。时间复杂度分析：链表中每个节点只被遍历一次，所以时间复杂度是 O(n)。123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode *tail = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return tail; &#125;&#125;; LeetCode 21. Merge Two Sorted Lists题目链接：Merge Two Sorted Lists题解：Merge Two Sorted Lists12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummy = new ListNode(0); ListNode *cur = dummy; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1 -&gt; val &lt; l2 -&gt; val) &#123; cur -&gt; next = l1; l1 = l1 -&gt; next; &#125; else &#123; cur -&gt; next = l2; l2 = l2 -&gt; next; &#125; cur = cur -&gt; next; &#125; cur -&gt; next = (l1 != NULL ? l1 : l2); return dummy -&gt; next; &#125;&#125;; 给定两个链表，请找它们的交汇点。题目链接：LeetCode 160. Intersection of Two Linked Lists题解：题解方便理解，画了一个图：12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p = headA, *q = headB; while (p != q) &#123; if (p) p = p-&gt;next; else p = headB; if (q) q = q-&gt;next; else q = headA; &#125; return p; &#125;&#125;; 给定一个链表，判断是否存在环题目链接：LeetCode 141. Linked List Cycle题解：题解12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (!head || !head-&gt;next) return 0; ListNode *first = head, *second = head; while (first &amp;&amp; second) &#123; first = first-&gt;next; second = second-&gt;next; if (second) second = second-&gt;next; if (first == second) return true; &#125; return false; &#125;&#125;; 使用插入排序对一个链表排序题目链接：LeetCode 147. Insertion Sort List 题解：题解1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; ListNode *dumy = new ListNode(-1); while (head) &#123; ListNode *next = head-&gt;next; ListNode *p = dumy; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt;= head-&gt;val) p = p-&gt;next; head-&gt;next = p-&gt;next; //头插法 p-&gt;next = head; head = next; &#125; return dumy-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void push_down(vector&lt;int&gt; &amp;heap, int size, int u) &#123; int t = u, left = u * 2, right = u * 2 + 1; if (left &lt;= size &amp;&amp; heap[left] &gt; heap[t]) t = left; if (right &lt;= size &amp;&amp; heap[right] &gt; heap[t]) t = right; if (t != u) &#123; swap(heap[u], heap[t]); push_down(heap, size, t); &#125;&#125;void push_up(vector&lt;int&gt; &amp;heap, int u) &#123; while (u / 2 &amp;&amp; heap[u / 2] &lt; heap[u]) &#123; swap(heap[u / 2], heap[u]); u /= 2; &#125;&#125;void heap_sort(vector&lt;int&gt; &amp;q, int n) &#123; int size = n; for (int i = 1; i&lt;=n; i++) push_up(q, i); for (int i = 1; i&lt;=n; i++) &#123; swap(q[1], q[size]); size --; push_down(q, size, 1); &#125;&#125;void insert(vector&lt;int&gt; &amp;heap, int size, int x) &#123; heap[ ++ size] = x; push_up(heap, x);&#125;void remove_top(vector&lt;int&gt; &amp;heap, int &amp;size) &#123; heap[1] = heap[size]; size -- ; push_down(heap, size, 1);&#125;int main() &#123; vector&lt;int&gt; q; int n; cin &gt;&gt; n; q.resize(n+1); for (int i = 1; i&lt;=n; i++) cin &gt;&gt; q[i]; heap_sort(q, n); for (int i = 1; i&lt;=n; i++) cout &lt;&lt; q[i] &lt;&lt; " " ; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吴恩达-《深度学习》编程作业]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%90%B4%E6%81%A9%E8%BE%BE-%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[Neural Networks and Deep LearningNeural Networks Basics Python Basics with numpy (optional) Logistic Regression with a Neural Network mindset]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习与机器学习笔记]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[LR与SVM的异同参考链接：参考1 参考2 逻辑回归 CNN简介参考链接：参考链接 TensorFlow实现CNN参考链接：参考链接 TensorFlow中CNN的两种padding方式“SAME”和“VALID”参考链接：参考链接 【TensorFlow】tf.nn.softmax_cross_entropy_with_logits的用法参考链接：参考链接]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>吴恩达</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持向量机]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[参考链接：支持向量机 支持向量机]]></content>
      <categories>
        <category>机器学习&amp;深度学习</category>
      </categories>
      <tags>
        <tag>SVM</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++知识点]]></title>
    <url>%2F2019%2F03%2F23%2FC%2B%2B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[侯捷老师－C++课件_面向对象高级编程：链接 什么是深复制？什么是浅复制？（深拷贝与浅拷贝）参考链接：深拷贝与浅拷贝 经典分类 不带指针的类(complex) 带指针的类(string)头文件中的防卫式声明 123456#ifndef __COMPLEX__#define __COMPLEX__..........#endif 模板(class template)12345678910111213141516171819template&lt;typename T&gt;class complex&#123;public: complex (T r = 0, T i = 0) : re(r), im(i) &#123; &#125; complex&amp; operator += (const complex&amp;); T real () const &#123; return re; &#125; T imag () const &#123; return im; &#125;private: T re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;;&#123; complex&lt;double&gt; c1(2.5, 1.5); complex&lt;int&gt; c2(2, 6);&#125; 内联函数(inline)函数在类本体内定义则是内联函数，否则不是。所有函数都可以写成inline，但有些函数定义为inline，但是编译器没有能力将他做成inline。（函数过于复杂则不能） 访问级别 private层变量只能class本体成员函数访问。 构造函数 创建一个对象时候，一个函数会自动调用起来，这个函数就是构造函数。 构造函数没有返回值。 构造函数可以有默认值。 初始化参数：仅构造函数才享有。 构造函数有两个阶段： 初始化阶段。（这就是初始化参数的效果，如果不那样做，就等于放弃了初始化阶段，从而效率变差。） 赋值阶段。12345678910111213141516171819202122class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; //初始化参数 /* 相当于 complex (double r = 0, double i = 0) &#123; re = r; im = i; &#125; */ complex&amp; operator += (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;;&#123; complex c1(2, 1); complex c2; complex* p = new complex(4); ...&#125; 构造函数可以有很多个－overloading（重载）12double real () const &#123; return re; &#125;void real (double r) &#123; re = r; &#125; 1234567891011121314151617class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; //初始化参数 complex () : re(0), im(0) &#123; &#125; //这种写法不行，会使得编译器犹豫不知道选择哪一个 /* complex c1; complex c2(); */ complex&amp; operator += (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 构造函数放在private区 singleton:外部只有一个接口访问这个类，单例模式。1234567891011121314class A &#123;public: static A&amp; getInstance(); setup() &#123; ... &#125;private: A(); A(const A&amp; rhs); ...&#125;;A&amp; A::getInstance() &#123; static A a; return a;&#125;; 调用时候，不能用传统方式A a(); 只能用A::getInstance().setup(); 常量成员函数(const member functions)函数分为内部改变数据的与内部不会改变数据的。不会改变数据的则最好使用const。12double real() const &#123; return re; &#125;double imag() const &#123; return im; &#125; 函数该加const时候不加const的后果这样调用是ok 的。12345&#123; complex c1(2, 1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();&#125; 下面这种情况不加，当c1.real()执行时，real()函数后面没有加const，此时，c1.real()语句是const，不能更改，然后real()函数会发生更改，所以会导致编译器错误。12345&#123; const complex c1(2, 1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();&#125; 参数传递：pass by value vs. pass by reference(to const)值传递：整个包都会传递过去，效率较差。尽量所有参数都传引用。传递速度很快，且不能更改：则pass by reference to const。123456789101112131415class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; //初始化参数 /* 相当于 complex (double r = 0, double i = 0) &#123; re = r; im = i; &#125; */ complex&amp; operator += (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 返回值传递：return by value vs. return by reference(to const)123ostream&amp; operator &lt;&lt; (ostream&amp; os, const complex&amp; x) &#123; return os &lt;&lt; '(' &lt;&lt; real(x) &lt;&lt; ',' &lt;&lt; imag(x) &lt;&lt; ')';&#125; 友元(friend) 友元函数是可以直接访问类的私有成员的非成员函数。 它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend。参考链接：友元12345inline complex&amp; __doapl(complex* ths, const complex&amp; r) &#123; ths-&gt;re += r.re; //自由取得friend的private成员 ths-&gt;im += r.im; return *ths;&#125; 相同class 的各个objects互为friends(友元)1234567891011121314151617class complex &#123;public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; int func(const complex&amp; param) &#123; //完美解释 return param.re + param.im; &#125;private: double re, im;&#125;;&#123; complex c1(2, 1); complex c2; c2.func(c1);&#125; 操作符重载－１， 成员函数，this123456789101112131415161718192021inline complex&amp; __doapl(complex* ths, const complex&amp; r) &#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;&#125;inline complex&amp; complex::operator += (const complex&amp; r) &#123; return __doapl (this, r);&#125;&#123; complex c1(2, 1); complex c2(5); c2 += c1;&#125;====&gt;&gt;&gt;//所有成员函数都带有一个隐藏的this 指针inline complex&amp; complex::operator += (this, const complex&amp; r) &#123; return __doapl (this, r);&#125; return by reference 语法分析 传递着无需知道接受者是以reference形式接收123456789inline complex&amp; __doapl(complex* ths, const complex&amp; r) &#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;&#125;inline complex&amp; complex::operator += (const complex&amp; r) &#123; return __doapl (this, r);&#125; 操作符重载－２，非成员函数(无this) 类里面带着指针12string s3(s1); //拷贝构造string s3 = s2; //拷贝赋值 12345 String(const String&amp; str); //拷贝构造 String&amp; operator=(const String&amp; str); //拷贝赋值private: ... char* m_data; //最好写成动态形式 1delete[] m_data; //析构清理 会导致内存泄露，制造野指针，变成孤儿（浅拷贝）。 深拷贝 三步：１、先分配空间。２、重新创造自己。３、拷贝过来。必须要进行检测自我赋值。如果相同时候结果会出错，将原地址也清空了。 stack自动释放，而heap必须手动释放。 静态，作用域结束之后仍然存在。 全局作用域。 new分为三个动作：１、分配内存。２、转型。３、构造函数。 delete两个动作：１、析构函数。２、delete. ==&gt;&gt;后面是以c的调用。相同的函数传递的是不同的地址。成员函数有一个隐藏的this指针，可以在函数中去使用它，在参数列中不可以写。加上static后不属于某一个对象，只有一份。静态函数没有this指针，指针去存取静态数据，不能像一般成员函数那样存取一般数据成员。 静态数据一定要在类的外部设置初值（定义）。 静态函数只能处理静态数据。两种调用方式：类调用、对象调用。 这个才是更好的写法。有调用a 才会出现，使得资源不浪费。 生成的class只想产生一个对象。这里的A只有一份，设置静态函数使得与外界联系的唯一接口。这里如果没有创建a，则会浪费资源。 模板写法。T 只是一个符号而已。 编译器会对函数模板进行参数推到。&lt;操作符重载。 所有东西被包装一个namespace里面，防止自己写的与其他人写的重名。也可以不一下全部打开，一条一条的打开。 里面有另外一个东西。queue里面有一个deque。A has a B,A的功能让B去完成。Adapter设计模式。queue是一个Adapter. 构造由内而外，析构由外而内。 父类的析构函数必须是virtual. 纯虚函数：子类一定要去重新定义他，父类并没有去定义。这也是一种设计模式。 既有继承，又有复合，构造时候谁先？]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[概述二分查找算法是针对有序数组的一个查找，又称为折半查找，时间复杂度为$log_2n$，空间复杂度为$O(1)$12345678910int binary_search(vector&lt;int&gt; a, int key) &#123; int start = 0, end = a.size()-1, mid = 0; while (start&lt;=right) &#123; mid = (start+end)&gt;&gt;2; if (a[mid] == key) return mid; //查找成功返回下标 else if (key &lt; a[mid]) mid = end-1; else mid = start+1; &#125; return -1; //查找失败返回-1&#125; 示例 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 数组旋转之后，第一个元素是大于等于最后一个元素的（有特殊情况），可用两个指针分别标记第一个跟最后一个元素。可以找到中间元素，如果中间元素大于第一个元素，那么最小元素肯定位于中间元素到最后一个元素之间。则递归后面部分即可。如果中间元素小于最后一个元素，则位于前面部分。最后两个指针相邻，也就是第一个指针指向前面数组部分的最后一个元素，第二个指针指向后面数组部分的第一个元素，即为循环结束条件，第二个指针指向的元素即为最小元素。123456789101112131415161718192021222324252627class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int p = rotateArray.size(); if (p == 0) return 0; int index1 = 0, index2 = p-1; int indexMid = index1; while (rotateArray[index1] &gt;= rotateArray[index2]) &#123; if (index2-index1 == 1) &#123; indexMid = index2; break; &#125; indexMid = (index1+index2)/2; //如果三个下标所对应元素值相同则顺序查找 if (rotateArray[index1] == rotateArray[indexMid] &amp;&amp; rotateArray[indexMid] == rotateArray[index2]) &#123; int minn = rotateArray[index1]; for (int i = index1+1; i&lt;=index2; i++) &#123; if (rotateArray[i] &lt; minn) minn = rotateArray[i]; &#125; return minn; &#125; if (rotateArray[indexMid] &gt;= rotateArray[index1]) index1 = indexMid; else if (rotateArray[indexMid] &lt;= rotateArray[index2]) index2 = indexMid; &#125; return rotateArray[indexMid]; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链接收藏]]></title>
    <url>%2F2019%2F03%2F23%2F%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[机器学习&amp;深度学习 吴恩达深度学习课程笔记 深度学习-红色石头-笔试面试 机器学习/深度学习笔试面试——正则化（L1与L2）篇 斯坦福CS231n-计算机视觉—笔记汇总 反向传播算法（过程及公式推导 TensorFlow TensorFlow入门笔记 算法&amp;数据结构 位图法(bitmap) 归并排序 C++C++多线程在多线程环境下，每个线程拥有一个栈和一个程序计数器。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。 C++多线程]]></content>
      <categories>
        <category>链接收藏</category>
      </categories>
      <tags>
        <tag>链接收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[参考链接：快速排序 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[1000];void quickSort(int a[], int left, int right)&#123; if (left &gt; right) return ; int i = left, j = right; int splitNum = a[i]; while (i != j) &#123; while (a[j]&gt;=splitNum &amp;&amp; i&lt;j) j--; while (a[i]&lt;=splitNum &amp;&amp; i&lt;j) i++; if (i&lt;j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; a[left] = a[i]; a[i] = splitNum; quickSort(a, left, i-1); quickSort(a, i+1, right);&#125;int main() &#123; while (cin &gt;&gt;n) &#123; for (int i = 0; i&lt;n; i++) cin &gt;&gt;a[i]; quickSort(a, 0, n-1); for (int i = 0; i&lt;n; i++) cout &lt;&lt; a[i] &lt;&lt; " " ; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
